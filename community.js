// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  I.CommunityArchiveTopicLightbox = (function(superClass) {
    extend(CommunityArchiveTopicLightbox, superClass);

    function CommunityArchiveTopicLightbox() {
      this.init = bind(this.init, this);
      return CommunityArchiveTopicLightbox.__super__.constructor.apply(this, arguments);
    }

    CommunityArchiveTopicLightbox.prototype.init = function() {
      var form;
      this.with_redactor((function(_this) {
        return function() {
          return I.redactor(_this.el.find("textarea"), {
            minHeight: 100,
            source: false
          });
        };
      })(this));
      return form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          form.set_form_errors(res.errors);
          if (res.errors) {
            return;
          }
          return window.location.reload();
        };
      })(this));
    };

    return CommunityArchiveTopicLightbox;

  })(I.Lightbox);

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  I.CommunityBanLightbox = (function(superClass) {
    extend(CommunityBanLightbox, superClass);

    function CommunityBanLightbox() {
      this.init = bind(this.init, this);
      return CommunityBanLightbox.__super__.constructor.apply(this, arguments);
    }

    CommunityBanLightbox.prototype.init = function() {
      var form;
      this.with_redactor((function(_this) {
        return function() {
          return I.redactor(_this.el.find("textarea"), {
            minHeight: 100,
            source: false
          });
        };
      })(this));
      return form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          form.set_form_errors(res.errors);
          if (res.errors) {
            return;
          }
          return _this.el.addClass("after_ban");
        };
      })(this));
    };

    return CommunityBanLightbox;

  })(I.Lightbox);

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityCategoryBans = (function() {
    function CommunityCategoryBans(el) {
      this.el = $(el);
      this.el.remote_link((function(_this) {
        return function(res) {
          if (res.errors) {
            alert(res.errors.join("\n"));
            return;
          }
          return window.location.reload();
        };
      })(this));
    }

    return CommunityCategoryBans;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityCategoryModerators = (function() {
    function CommunityCategoryModerators(el) {
      this.el = $(el);
      this.el.remote_link((function(_this) {
        return function(res, el) {
          if (res.return_to) {
            return window.location = res.return_to;
          }
        };
      })(this));
    }

    return CommunityCategoryModerators;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityProfile = (function() {
    function CommunityProfile(el, opts) {
      var c;
      this.el = $(el);
      new I.FilterPickers(this.el);
      this.carousels = (function() {
        var i, len, ref, results;
        ref = this.el.find(".game_carousel_widget");
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(new I.GameCarousel($(c)));
        }
        return results;
      }).call(this);
      new I.CommunityViewTopic(this.el.find(".recent_posts"), opts);
    }

    return CommunityProfile;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityEditCategory = (function() {
    function CommunityEditCategory(el) {
      var form;
      this.el = $(el);
      form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          if (res.errors) {
            form.set_form_errors(res.errors);
            return;
          }
          if (res.redirect_to) {
            return window.location = res.redirect_to;
          }
        };
      })(this));
    }

    return CommunityEditCategory;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.GameCommunityCategory = (function() {
    function GameCommunityCategory(el) {
      var scroller;
      this.el = $(el);
      scroller = this.el.find(".blog_post_grid_widget");
      scroller.lazy_images({
        horizontal: true,
        target: scroller
      });
    }

    return GameCommunityCategory;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.GameCommunityHeader = (function() {
    function GameCommunityHeader(el) {
      this.el = $(el);
      this.el.dispatch("click", {
        add_to_collection_btn: (function(_this) {
          return function(btn) {
            if (!I.current_user) {
              return "continue";
            }
            return I.Lightbox.open_remote(btn.attr("href"), I.CollectionLightbox);
          };
        })(this)
      });
    }

    return GameCommunityHeader;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  I.CommunityLockTopicLightbox = (function(superClass) {
    extend(CommunityLockTopicLightbox, superClass);

    function CommunityLockTopicLightbox() {
      this.init = bind(this.init, this);
      return CommunityLockTopicLightbox.__super__.constructor.apply(this, arguments);
    }

    CommunityLockTopicLightbox.prototype.init = function() {
      var form;
      this.with_redactor((function(_this) {
        return function() {
          return I.redactor(_this.el.find("textarea"), {
            minHeight: 100,
            source: false
          });
        };
      })(this));
      return form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          form.set_form_errors(res.errors);
          if (res.errors) {
            return;
          }
          return window.location.reload();
        };
      })(this));
    };

    return CommunityLockTopicLightbox;

  })(I.Lightbox);

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityNewTopic = (function() {
    function CommunityNewTopic(el, opts) {
      var form;
      this.el = $(el);
      try {
        this.el.find("input[name=offset]").val(new Date().getTimezoneOffset());
      } catch (error) {}
      this.set_fingerprint();
      form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          if (res.errors) {
            if (I.add_recaptcha_if_necessary(form, res.errors)) {
              return;
            }
            form.set_form_errors(res.errors);
            return;
          }
          if (res.redirect_to) {
            return window.location = res.redirect_to;
          }
        };
      })(this));
    }

    CommunityNewTopic.prototype.set_fingerprint = function() {
      if (!window.Fingerprint2) {
        return false;
      }
      this.set_fingerprint = function() {};
      return new Fingerprint2().get((function(_this) {
        return function(res) {
          if (res) {
            return _this.el.find("input[name=bfp]").val(res);
          }
        };
      })(this));
    };

    return CommunityNewTopic;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityPostForm = (function() {
    function CommunityPostForm(el, opts) {
      var form;
      if (opts == null) {
        opts = {};
      }
      this.el = $(el);
      form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          if (res.errors) {
            if (I.add_recaptcha_if_necessary(form, res.errors)) {
              return;
            }
            form.set_form_errors(res.errors);
            return;
          }
          if (res.redirect_to) {
            window.location = res.redirect_to;
          }
          if (res.flash) {
            return I.flash(res.flash);
          }
        };
      })(this));
    }

    return CommunityPostForm;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  I.CommunityReportPostLightbox = (function(superClass) {
    extend(CommunityReportPostLightbox, superClass);

    function CommunityReportPostLightbox() {
      this.init = bind(this.init, this);
      return CommunityReportPostLightbox.__super__.constructor.apply(this, arguments);
    }

    CommunityReportPostLightbox.prototype.init = function() {
      var form;
      return form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          if (res.errors) {
            form.set_form_errors(res.errors);
            return;
          }
          return _this.el.addClass("submitted_report");
        };
      })(this));
    };

    return CommunityReportPostLightbox;

  })(I.Lightbox);

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  I.CommunityStickTopicLightbox = (function(superClass) {
    extend(CommunityStickTopicLightbox, superClass);

    function CommunityStickTopicLightbox() {
      this.init = bind(this.init, this);
      return CommunityStickTopicLightbox.__super__.constructor.apply(this, arguments);
    }

    CommunityStickTopicLightbox.prototype.init = function() {
      var form;
      this.with_redactor((function(_this) {
        return function() {
          return I.redactor(_this.el.find("textarea"), {
            minHeight: 100,
            source: false
          });
        };
      })(this));
      return form = this.el.find("form").remote_submit((function(_this) {
        return function(res) {
          form.set_form_errors(res.errors);
          if (res.errors) {
            return;
          }
          return window.location.reload();
        };
      })(this));
    };

    return CommunityStickTopicLightbox;

  })(I.Lightbox);

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  I.CommunityTopicHeader = (function() {
    function CommunityTopicHeader(el, opts) {
      var moderation;
      this.opts = opts;
      this.render_topic_voter = bind(this.render_topic_voter, this);
      this.el = $(el);
      moderation = this.el.find(".moderation_tools");
      if (moderation.length) {
        new I.CommunityTopicModerationTools(moderation, this.opts.moderation);
      }
      this.render_topic_voter();
    }

    CommunityTopicHeader.prototype.render_topic_voter = function() {
      var props, ref, voter;
      if (!(typeof R !== "undefined" && R !== null ? (ref = R.Community) != null ? ref.TopicVoter : void 0 : void 0)) {
        return;
      }
      voter = this.el.find(".community_topic_voter_widget");
      if (!voter.length) {
        return;
      }
      props = voter.data("p");
      props.vote_url = this.opts.vote_url;
      return ReactDOM.render(R.Community.TopicVoter(props), voter[0]);
    };

    return CommunityTopicHeader;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  I.CommunityTopicList = (function() {
    function CommunityTopicList(el, opts) {
      this.opts = opts;
      this.el = $(el);
      new I.CommunityTopicModerationTools(el, this.opts);
      this.el.lazy_images({
        selector: "[data-background_image]"
      });
      this.render_topic_voters();
      this.el.has_tooltips();
      new I.GamePopups(this.el);
    }

    CommunityTopicList.prototype.render_topic_voters = function() {
      var i, len, props, ref, ref1, results, voter;
      if (!(typeof R !== "undefined" && R !== null ? (ref = R.Community) != null ? ref.TopicVoter : void 0 : void 0)) {
        return;
      }
      ref1 = this.el.find(".community_topic_voter_widget");
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        voter = ref1[i];
        props = $(voter).data("p");
        props.vote_url = this.opts.vote_url;
        results.push(ReactDOM.render(R.Community.TopicVoter(props), voter));
      }
      return results;
    };

    return CommunityTopicList;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  I.CommunityTopicModerationTools = (function() {
    CommunityTopicModerationTools.prototype.topic_url = function(route, topic_id) {
      return this.opts.urls[route].replace(/:topic_id\b/, topic_id);
    };

    function CommunityTopicModerationTools(el, opts) {
      this.opts = opts;
      this.topic_url = bind(this.topic_url, this);
      this.el = $(el);
      new I.FilterPickers(el);
      this.el.on("click", ".filter_option", (function(_this) {
        return function(e) {
          var target, topic_id, value;
          target = $(e.currentTarget).trigger("i:close_filter_pickers");
          topic_id = target.closest("[data-topic_id]").data("topic_id");
          value = target != null ? target.data("value") : void 0;
          switch (value) {
            case "purge":
              e.preventDefault();
              if (confirm("This will delete all the users posts and spam their account. No undo. Are you sure?")) {
                return $.post($(e.currentTarget).attr("href"), I.with_csrf()).done(function(res) {
                  if (res.errors) {
                    alert(res.errors.join(","));
                    return;
                  }
                  if (res.redirect_to) {
                    return window.location = res.redirect_to;
                  }
                });
              }
              break;
            case "feature":
            case "unfeature":
            case "bump":
              e.preventDefault();
              return $.post($(e.currentTarget).attr("href"), I.with_csrf()).done(function(res) {
                if (res.errors) {
                  alert(res.errors.join(","));
                  return;
                }
                if (res.redirect_to) {
                  return window.location = res.redirect_to;
                }
              });
            case "archive":
            case "unarchive":
              e.preventDefault();
              return I.Lightbox.open_remote(_this.topic_url("archive_topic", topic_id), I.CommunityArchiveTopicLightbox);
            case "lock":
            case "unlock":
              e.preventDefault();
              return I.Lightbox.open_remote(_this.topic_url("lock_topic", topic_id), I.CommunityLockTopicLightbox);
            case "stick":
            case "unstick":
              e.preventDefault();
              return I.Lightbox.open_remote(_this.topic_url("stick_topic", topic_id), I.CommunityStickTopicLightbox);
            case "delete":
              e.preventDefault();
              if (confirm("Are you sure you want to delete this topic?")) {
                return $.ajax({
                  url: _this.topic_url("delete_topic", topic_id),
                  data: I.with_csrf(),
                  type: "post",
                  xhrFields: {
                    withCredentials: true
                  }
                }).done(function(res) {
                  if (res.errors) {
                    return alert(res.errors.join());
                  }
                  return window.location.reload();
                });
              }
          }
        };
      })(this));
    }

    return CommunityTopicModerationTools;

  })();

}).call(this);
// Generated by CoffeeScript 1.12.7
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  I.CommunityViewTopic = (function() {
    CommunityViewTopic.prototype.vote_counts_template = I.lazy_template(CommunityViewTopic, "vote_counts");

    function CommunityViewTopic(el, opts) {
      var src;
      this.opts = opts;
      this.update_votes = bind(this.update_votes, this);
      this.el = $(el);
      if (this.el.find("code[class*=language-]").exists()) {
        if (src = $("#lib_prism_src").data("inject")) {
          $(document.body).append(src);
        }
      }
      this.el.remote_link((function(_this) {
        return function(res, el) {
          if (el.is(".vote_btn")) {
            if (res.errors) {
              alert(res.errors.join(", "));
              return;
            }
            _this.update_votes(el, res);
            return;
          }
          if (res.redirect_to) {
            return window.location = res.redirect_to;
          }
        };
      })(this));
      this.el.dispatch("click", {
        ban_user_btn: (function(_this) {
          return function(btn) {
            var ban_url, post;
            post = btn.closest(".community_post").data("post");
            ban_url = _this.opts.ban_url + ("?banned_user_id=" + post.user_id);
            return I.Lightbox.open_remote(ban_url, I.CommunityBanLightbox);
          };
        })(this),
        stick_topic_btn: (function(_this) {
          return function(btn) {
            return I.Lightbox.open_remote(btn.data("href"), I.CommunityStickTopicLightbox);
          };
        })(this),
        lock_topic_btn: (function(_this) {
          return function(btn) {
            return I.Lightbox.open_remote(btn.data("href"), I.CommunityLockTopicLightbox);
          };
        })(this),
        report_post_btn: (function(_this) {
          return function(btn) {
            var post, url;
            post = btn.closest(".community_post").data("post");
            url = _this.opts.report_url.replace(/:post_id/, post.id);
            return I.Lightbox.open_remote(url, I.CommunityReportPostLightbox);
          };
        })(this),
        embed_preload: (function(_this) {
          return function(btn) {
            var code;
            if (btn[0].hasAttribute("itchio")) {
              code = btn.data("embed_code");
              return btn.replaceWith(code);
            }
          };
        })(this)
      });
    }

    CommunityViewTopic.prototype.update_votes = function(el, res) {
      var i, len, like_button, post, v, voters;
      post = el.closest(".community_post");
      voters = post.find(".vote_btn");
      like_button = voters.filter(".post_action");
      like_button.removeClass("animate_bounce animate_drop_down");
      setTimeout((function(_this) {
        return function() {
          return like_button.removeClass("animate_bounce animate_drop_down");
        };
      })(this), 500);
      if (el.is(".voted")) {
        _.defer((function(_this) {
          return function() {
            return like_button.addClass("animate_drop_down");
          };
        })(this));
        el.removeClass("voted");
      } else {
        _.defer((function(_this) {
          return function() {
            return like_button.addClass("animate_bounce");
          };
        })(this));
        voters.removeClass("voted").filter(el).addClass("voted");
      }
      for (i = 0, len = voters.length; i < len; i++) {
        v = voters[i];
        v = $(v);
        if (v.is(".voted")) {
          v.data("params").action = "remove";
        } else {
          delete v.data("params").action;
        }
      }
      return post.find(".vote_counts").html(this.vote_counts_template({
        up_score: res.up_score + Math.max(0, res.score_adjustment),
        down_score: res.down_score + Math.abs(Math.min(0, res.score_adjustment))
      }));
    };

    return CommunityViewTopic;

  })();

}).call(this);
(function() {
  I.libs.react.done(function() {;
  var P, _rdf, a, abbr, br, button, code, div, em, fieldset, form, fragment, h1, h2, h3, h4, h5, h6, iframe, img, input, label, legend, li, ol, optgroup, option, p, pre, section, select, span, strong, table, tbody, td, textarea, thead, tr, types, ul;

  _rdf = ReactDOMFactories;

  div = _rdf.div, span = _rdf.span, a = _rdf.a, br = _rdf.br, p = _rdf.p, ol = _rdf.ol, ul = _rdf.ul, li = _rdf.li, strong = _rdf.strong, em = _rdf.em, img = _rdf.img, form = _rdf.form, label = _rdf.label, input = _rdf.input, textarea = _rdf.textarea, button = _rdf.button, iframe = _rdf.iframe, h1 = _rdf.h1, h2 = _rdf.h2, h3 = _rdf.h3, h4 = _rdf.h4, h5 = _rdf.h5, h6 = _rdf.h6, pre = _rdf.pre, code = _rdf.code, select = _rdf.select, option = _rdf.option, section = _rdf.section, optgroup = _rdf.optgroup, fieldset = _rdf.fieldset, legend = _rdf.legend;

  fragment = React.createElement.bind(null, React.Fragment);

  fragment.type = React.fragment;

  P = R["package"]("Community");

  types = PropTypes;

  table = ReactDOMFactories.table, thead = ReactDOMFactories.thead, tbody = ReactDOMFactories.tbody, tr = ReactDOMFactories.tr, td = ReactDOMFactories.td, abbr = ReactDOMFactories.abbr;

  P("CategoryEditTags", {
    propTypes: {
      tags: types.arrayOf(types.shape({
        id: types.number.isRequired,
        label: types.string.isRequired,
        color: types.string
      }))
    },
    getInitialState: function() {
      return {
        tags: _.toArray(this.props.tags)
      };
    },
    push_tag: function(tag) {
      tag = $.trim(tag);
      if (tag === "") {
        return;
      }
      return this.setState(function(state) {
        return {
          tags: state.tags.concat({
            label: tag
          })
        };
      });
    },
    remove_tag: function(idx) {
      this.state.tags.splice(idx, 1);
      return this.forceUpdate();
    },
    input_name: function(name, idx) {
      return "category_tags[" + (idx + 1) + "][" + name + "]";
    },
    render: function() {
      return this.enclose({}, this.state.tags.length ? table({
        className: "tag_list"
      }, tbody({}, this.state.tags.map((function(_this) {
        return function(tag, idx) {
          return tr({
            className: "tag_row",
            key: tag.id + "-" + tag.label
          }, td({}, tag.id != null ? input({
            type: "hidden",
            name: _this.input_name("id", idx),
            value: "" + tag.id
          }) : void 0, tag.color != null ? input({
            type: "hidden",
            name: _this.input_name("color", idx),
            value: tag.color
          }) : void 0, input({
            type: "hidden",
            name: _this.input_name("label", idx),
            value: tag.label
          }), span({
            className: "tag_label"
          }, tag.label)), td({}, input({
            type: "text",
            name: _this.input_name("description", idx),
            defaultValue: tag.description,
            placeholder: "Description, optional"
          })), td({}, button({
            className: "textlike",
            onClick: function(e) {
              if (confirm("Are you sure you want to remove this tag?")) {
                e.preventDefault();
                return _this.remove_tag(idx);
              }
            }
          }, "remove")));
        };
      })(this)))) : void 0, input({
        type: "text",
        placeholder: "Type tag name and press enter to add tag",
        maxLength: 30,
        onKeyDown: (function(_this) {
          return function(e) {
            if (e.keyCode !== 13) {
              return;
            }
            e.preventDefault();
            _this.push_tag(e.target.value);
            return e.target.value = "";
          };
        })(this)
      }));
    }
  });

  });

}).call(this);
(function() {
  I.libs.react.done(function() {;
  var P, _rdf, a, br, button, code, div, em, fieldset, form, fragment, h1, h2, h3, h4, h5, h6, iframe, img, input, key_counter, label, legend, li, ol, optgroup, option, p, pre, section, select, span, strong, textarea, types, ul,
    slice = [].slice;

  _rdf = ReactDOMFactories;

  div = _rdf.div, span = _rdf.span, a = _rdf.a, br = _rdf.br, p = _rdf.p, ol = _rdf.ol, ul = _rdf.ul, li = _rdf.li, strong = _rdf.strong, em = _rdf.em, img = _rdf.img, form = _rdf.form, label = _rdf.label, input = _rdf.input, textarea = _rdf.textarea, button = _rdf.button, iframe = _rdf.iframe, h1 = _rdf.h1, h2 = _rdf.h2, h3 = _rdf.h3, h4 = _rdf.h4, h5 = _rdf.h5, h6 = _rdf.h6, pre = _rdf.pre, code = _rdf.code, select = _rdf.select, option = _rdf.option, section = _rdf.section, optgroup = _rdf.optgroup, fieldset = _rdf.fieldset, legend = _rdf.legend;

  fragment = React.createElement.bind(null, React.Fragment);

  fragment.type = React.fragment;

  P = R["package"]("Community");

  types = PropTypes;

  key_counter = 0;

  P("EditCategories", {
    propTypes: {
      category: types.object
    },
    getInitialState: function() {
      return {
        children: _.toArray(this.props.category.children)
      };
    },
    componentDidMount: function() {
      return this.dispatch("category", {
        create: (function(_this) {
          return function() {
            _this.state.children.push({
              key: key_counter += 1
            });
            return _this.forceUpdate();
          };
        })(this),
        set_property: (function(_this) {
          return function(e, category, property, value) {
            category[property] = value;
            return _this.forceUpdate();
          };
        })(this),
        create_child: (function(_this) {
          return function(e, category) {
            category.children || (category.children = []);
            category.children.push({
              key: key_counter += 1
            });
            return _this.forceUpdate();
          };
        })(this),
        remove_child: (function(_this) {
          return function(e, category, idx) {
            var children;
            children = category === _this.props.category ? _this.state.children : category.children;
            children.splice(idx, 1);
            return _this.forceUpdate();
          };
        })(this),
        toggle: (function(_this) {
          return function(e, category, field) {
            category[field] = !category[field];
            return _this.forceUpdate();
          };
        })(this),
        move_up: (function(_this) {
          return function(e, category, idx) {
            var c, children, ref, swap_with;
            children = category === _this.props.category ? _this.state.children : category.children;
            swap_with = idx - 1;
            if (!children[swap_with]) {
              return;
            }
            c = children;
            ref = [c[swap_with], c[idx]], c[idx] = ref[0], c[swap_with] = ref[1];
            return _this.forceUpdate();
          };
        })(this),
        move_down: (function(_this) {
          return function(e, category, idx) {
            var c, children, ref, swap_with;
            children = category === _this.props.category ? _this.state.children : category.children;
            swap_with = idx + 1;
            if (!children[swap_with]) {
              return;
            }
            c = children;
            ref = [c[swap_with], c[idx]], c[idx] = ref[0], c[swap_with] = ref[1];
            return _this.forceUpdate();
          };
        })(this)
      });
    },
    render: function() {
      return form({
        method: "POST",
        className: "edit_categories form"
      }, R.CSRF({}), h2({}, "Subcategories"), this.state.children.length ? div({
        className: "category_list",
        children: _.map(this.state.children, (function(_this) {
          return function(cat, idx) {
            return P.CategoryRow({
              is_first: idx === 0,
              is_last: idx === (_this.state.children.length - 1),
              key: cat.key || ("cat" + cat.id),
              parent_category: _this.props.category,
              category: cat,
              position: idx + 1
            });
          };
        })(this))
      }) : p({}, em({
        className: "empty_message"
      }, "There are no categories. You must have at least one non-directory category for your community to be usable.")), div({
        className: "button_row"
      }, button({
        className: "button",
        onClick: (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.trigger("category:create");
          };
        })(this)
      }, "New category"), " ", button({
        className: "button"
      }, "Save")));
    }
  });

  P("CategoryRow", {
    propTypes: {
      is_first: types.bool,
      is_last: types.bool,
      position: types.number,
      category: types.shape({
        id: types.number,
        title: types.string
      }),
      input_prefix: types.string
    },
    input_name: function(name) {
      var prefix;
      prefix = this.props.input_prefix || "categories";
      return prefix + "[" + (this.props.position || "") + "][" + name + "]";
    },
    render: function() {
      var count, ref;
      return div({
        className: "category_row"
      }, this.props.category.id ? input({
        type: "hidden",
        name: this.input_name("id"),
        value: this.props.category.id
      }) : void 0, div.apply(null, [{
        className: "category_primary_inputs"
      }].concat(slice.call(this.render_title_inputs()))), div.apply(null, [{
        className: "category_secondary_inputs"
      }].concat(slice.call(this.render_button_inputs()))), div({
        className: "category_secondary_inputs"
      }, label({}, input({
        type: "checkbox",
        name: this.input_name("archived"),
        checked: this.props.category.archived || false,
        onChange: (function(_this) {
          return function(e) {
            return _this.trigger("category:toggle", _this.props.category, "archived");
          };
        })(this)
      }), span({
        className: "label"
      }, "Archive")), label({}, input({
        type: "checkbox",
        name: this.input_name("hidden"),
        checked: this.props.category.hidden || false,
        onChange: (function(_this) {
          return function(e) {
            return _this.trigger("category:toggle", _this.props.category, "hidden");
          };
        })(this)
      }), span({
        className: "label"
      }, "Hidden")), label({}, input({
        type: "checkbox",
        name: this.input_name("directory"),
        checked: this.props.category.directory || false,
        onChange: (function(_this) {
          return function(e) {
            return _this.trigger("category:toggle", _this.props.category, "directory");
          };
        })(this)
      }), span({
        className: "label"
      }, "Directory")), this.props.category.created_at ? span({
        className: "created_at",
        title: this.props.category.created_at
      }, I.format_timestamp(this.props.category.created_at, "calendar")) : void 0, !this.props.category.directory && (this.props.category.topics_count != null) ? (count = this.props.category.topics_count, span({
        className: "topics_count"
      }, count + " topic" + (count === 1 && "" || "s"))) : void 0, this.props.category.url ? a({
        className: "category_link",
        href: this.props.category.url
      }, "View") : void 0, this.props.category.edit_url ? a({
        className: "category_link",
        href: this.props.category.edit_url
      }, "Edit") : void 0), ((ref = this.props.category.children) != null ? ref.length : void 0) ? div({
        className: "child_categories",
        children: _.map(this.props.category.children, (function(_this) {
          return function(cat, idx) {
            return P.CategoryRow({
              is_first: idx === 0,
              is_last: idx === (_this.props.category.children - 1),
              key: cat.key || ("cat" + cat.id),
              input_prefix: (_this.props.input_prefix || "categories") + "[" + _this.props.position + "][children]",
              parent_category: _this.props.category,
              category: cat,
              position: idx + 1
            });
          };
        })(this))
      }) : void 0);
    },
    render_title_inputs: function() {
      return [
        !this.props.category.id ? span({
          className: "new_flag"
        }, "New") : void 0, input({
          type: "text",
          className: "title_input text_input",
          name: this.input_name("title"),
          required: "required",
          value: this.props.category.title || "",
          placeholder: "Title",
          onChange: (function(_this) {
            return function(e) {
              return _this.trigger("category:set_property", _this.props.category, "title", e.target.value);
            };
          })(this)
        }), !this.props.category.directory ? input({
          type: "text",
          className: "short_description_input text_input",
          name: this.input_name("short_description"),
          value: this.props.category.short_description || "",
          placeholder: "Short description",
          onChange: (function(_this) {
            return function(e) {
              return _this.trigger("category:set_property", _this.props.category, "short_description", e.target.value);
            };
          })(this)
        }) : void 0
      ];
    },
    render_button_inputs: function() {
      return [
        button({
          className: "button small",
          onClick: (function(_this) {
            return function(e) {
              e.preventDefault();
              return _this.trigger("category:create_child", _this.props.category);
            };
          })(this)
        }, "Add child"), !this.props.is_first ? a({
          href: "#",
          className: "move_btn move_up_btn",
          onClick: (function(_this) {
            return function(e) {
              e.preventDefault();
              return _this.trigger("category:move_up", _this.props.parent_category, _this.props.position - 1);
            };
          })(this)
        }, "Move up") : void 0, !this.props.is_last ? a({
          href: "#",
          className: "move_btn move_down_btn",
          onClick: (function(_this) {
            return function(e) {
              e.preventDefault();
              return _this.trigger("category:move_down", _this.props.parent_category, _this.props.position - 1);
            };
          })(this)
        }, "Move down") : void 0, a({
          href: "#",
          className: "remove_btn",
          onClick: (function(_this) {
            return function(e) {
              e.preventDefault();
              if (confirm("Are you sure you want to remove?")) {
                return _this.trigger("category:remove_child", _this.props.parent_category, _this.props.position - 1);
              }
            };
          })(this)
        }, "Remove")
      ];
    }
  });

  });

}).call(this);
(function() {
  I.libs.react.done(function() {;
  var P, _rdf, a, br, button, code, div, em, fieldset, form, fragment, h1, h2, h3, h4, h5, h6, iframe, img, input, label, legend, li, ol, optgroup, option, p, pre, section, select, span, strong, textarea, types, ul,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _rdf = ReactDOMFactories;

  div = _rdf.div, span = _rdf.span, a = _rdf.a, br = _rdf.br, p = _rdf.p, ol = _rdf.ol, ul = _rdf.ul, li = _rdf.li, strong = _rdf.strong, em = _rdf.em, img = _rdf.img, form = _rdf.form, label = _rdf.label, input = _rdf.input, textarea = _rdf.textarea, button = _rdf.button, iframe = _rdf.iframe, h1 = _rdf.h1, h2 = _rdf.h2, h3 = _rdf.h3, h4 = _rdf.h4, h5 = _rdf.h5, h6 = _rdf.h6, pre = _rdf.pre, code = _rdf.code, select = _rdf.select, option = _rdf.option, section = _rdf.section, optgroup = _rdf.optgroup, fieldset = _rdf.fieldset, legend = _rdf.legend;

  fragment = React.createElement.bind(null, React.Fragment);

  fragment.type = React.fragment;

  P = R["package"]("Community");

  types = PropTypes;

  P("PostLiker", {
    pure: true,
    getDefaultProps: function() {
      return {
        animation_duration: 500
      };
    },
    componentDidCatch: function(error, info) {
      return I.event("error", "react", "Community.PostLiker");
    },
    componentWillUnmount: function() {
      if (this.animation_timer) {
        window.clearTimeout(this.animation_timer);
        return this.animation_timer = null;
      }
    },
    componentDidUpdate: function(_, prev_state) {
      var ref1;
      if (((ref1 = this.state) != null ? ref1.animation : void 0) && (prev_state != null ? prev_state.animation : void 0) !== this.state.animation) {
        return this.animation_timer = window.setTimeout((function(_this) {
          return function() {
            return _this.setState({
              animation: null
            });
          };
        })(this), this.props.animation_duration);
      }
    },
    like: function() {
      var animation, future_animation, params, ref1, ref2;
      params = {
        direction: "up"
      };
      if ((ref1 = this.props.vote) != null ? ref1.positive : void 0) {
        params.action = "remove";
      }
      animation = params.action === "remove" ? "animate_drop_down" : "animate_bounce";
      if ((ref2 = this.state) != null ? ref2.animation : void 0) {
        future_animation = animation;
        _.defer((function(_this) {
          return function() {
            return _this.setState({
              animation: future_animation
            });
          };
        })(this));
        animation = null;
      }
      this.setState({
        loading: true,
        pending_vote: params.action !== "remove",
        animation: animation
      });
      return $.ajax({
        type: "POST",
        dataType: "json",
        url: this.props.urls.vote_url({
          id: this.props.post_id
        }),
        data: I.with_csrf(params),
        xhrFields: {
          withCredentials: true
        }
      }).done((function(_this) {
        return function(res) {
          var base;
          _this.setState({
            loading: false,
            pending_vote: void 0
          });
          return typeof (base = _this.props).on_vote === "function" ? base.on_vote(res) : void 0;
        };
      })(this)).fail((function(_this) {
        return function(xhr) {
          var res;
          _this.setState({
            loading: false
          });
          res = (function() {
            try {
              return JSON.parse(xhr.responseText);
            } catch (error1) {}
          })();
          if (res != null ? res.errors : void 0) {
            _this.setState({
              pending_vote: null
            });
          }
          if (res != null ? res.login_url : void 0) {
            return window.location = res.login_url;
          }
        };
      })(this));
    },
    render: function() {
      var ref1, ref2, ref3, ref4, ref5;
      if (!this.props.current_user) {
        return this.enclose({
          component: "a",
          className: classNames("post_action vote_btn", this.props.classNames),
          href: this.props.login_url,
          target: "_blank"
        }, R.Icons.TriUp, " ", this.tt("community.post_list.like"));
      }
      return this.enclose({
        component: "button",
        type: "button",
        className: classNames("post_action vote_btn", (ref1 = this.state) != null ? ref1.animation : void 0, this.props.classNames, {
          loading: (ref2 = this.state) != null ? ref2.loading : void 0,
          voted: (ref3 = (ref4 = this.state) != null ? ref4.pending_vote : void 0) != null ? ref3 : (ref5 = this.props.vote) != null ? ref5.positive : void 0
        }),
        onClick: this.on_click || (this.on_click = (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.like();
          };
        })(this))
      }, R.Icons.TriUp, " ", this.tt("community.post_list.like"));
    }
  });

  P("PostVoter", {
    pure: true,
    propTypes: {
      urls: types.object,
      post_id: types.number,
      vote: types.object
    },
    componentDidCatch: function(error, info) {
      return I.event("error", "react", "Community.PostVoter");
    },
    vote: function(dir) {
      var params, ref1, ref2;
      if ((ref1 = this.state) != null ? ref1.loading : void 0) {
        return;
      }
      params = {
        direction: dir
      };
      if (dir === "up" && ((ref2 = this.props.vote) != null ? ref2.positive : void 0)) {
        params.action = "remove";
      }
      if (dir === "down" && this.props.vote && !this.props.vote.positive) {
        params.action = "remove";
      }
      this.setState({
        loading: true
      });
      return $.ajax({
        type: "POST",
        url: this.props.urls.vote_url({
          id: this.props.post_id
        }),
        data: I.with_csrf(params),
        dataType: "json",
        xhrFields: {
          withCredentials: true
        }
      }).done((function(_this) {
        return function(res) {
          var base;
          _this.setState({
            loading: false
          });
          return typeof (base = _this.props).on_vote === "function" ? base.on_vote(res) : void 0;
        };
      })(this)).fail((function(_this) {
        return function(xhr) {
          var res;
          _this.setState({
            loading: false
          });
          res = (function() {
            try {
              return JSON.parse(xhr.responseText);
            } catch (error1) {}
          })();
          if (res != null ? res.login_url : void 0) {
            return window.location = res.login_url;
          }
        };
      })(this));
    },
    render: function() {
      var ref1;
      return this.enclose({
        className: classNames("post_votes", {
          loading: (ref1 = this.state) != null ? ref1.loading : void 0
        })
      }, this.props.current_user ? button({
        type: "button",
        disabled: this.props.disabled,
        className: classNames("vote_up_btn vote_btn", {
          voted: this.props.vote && this.props.vote.positive
        }),
        onClick: this.on_vote_up || (this.on_vote_up = (function(_this) {
          return function() {
            return _this.vote("up");
          };
        })(this))
      }, R.Icons.TriUp) : a({
        className: "vote_up_btn vote_btn",
        target: "_blank",
        rel: "nofollow",
        href: this.props.login_url
      }, R.Icons.TriUp), this.props.current_user ? button({
        type: "button",
        disabled: this.props.disabled,
        className: classNames("vote_down_btn vote_btn", {
          voted: this.props.vote && !this.props.vote.positive
        }),
        onClick: this.on_vote_down || (this.on_vote_down = (function(_this) {
          return function() {
            return _this.vote("down");
          };
        })(this))
      }, R.Icons.TriDown) : a({
        className: "vote_down_btn vote_btn",
        target: "_blank",
        rel: "nofollow",
        href: this.props.login_url
      }, R.Icons.TriDown));
    }
  });

  P("PostBody", {
    pure: true,
    getDefaultProps: function() {
      return {
        max_height: 300
      };
    },
    componentDidMount: function() {
      return _.defer((function(_this) {
        return function() {
          var buffer, images;
          images = $(_this.wrapper_ref.current).find("img").on("load", function() {
            return _this.refresh_sizes();
          });
          buffer = !images.length ? 50 : void 0;
          return _this.refresh_sizes(buffer);
        };
      })(this));
    },
    reveal: function() {
      return this.setState({
        open: true,
        has_more: false
      });
    },
    on_click: function(e) {
      var embed, ref1, ref2;
      if ((ref1 = this.state) != null ? ref1.has_more : void 0) {
        this.reveal();
      }
      embed = $(e.target).closest(".embed_preload");
      if (embed.length) {
        code = embed.data("embed_code");
        embed.replaceWith(code);
        if (!((ref2 = this.state) != null ? ref2.open : void 0)) {
          return this.setState({
            open: true
          });
        }
      }
    },
    refresh_sizes: function(buffer) {
      var total_height;
      if (!this.wrapper_ref.current) {
        return;
      }
      total_height = this.wrapper_ref.current.scrollHeight;
      if (total_height > this.props.max_height) {
        this.setState({
          has_more: true
        });
      }
      if (buffer) {
        if (total_height < this.props.max_height + buffer) {
          return this.setState({
            open: true,
            has_more: false
          });
        }
      }
    },
    render: function() {
      var ref1, ref2, style;
      style = !((ref1 = this.state) != null ? ref1.open : void 0) ? {
        "overflowY": "hidden",
        "maxHeight": this.props.max_height + "px"
      } : void 0;
      return fragment({}, div({
        className: "post_body user_formatted",
        ref: this.wrapper_ref || (this.wrapper_ref = React.createRef()),
        style: style,
        onClick: this.on_click,
        dangerouslySetInnerHTML: {
          __html: this.props.body_html
        }
      }), ((ref2 = this.state) != null ? ref2.has_more : void 0) ? button({
        type: "button",
        onClick: this.reveal,
        className: "reveal_full_post_btn"
      }, "View rest ↓") : void 0);
    }
  });

  P("Post", {
    pure: true,
    edit_post: function(update) {
      return this.props.edit_post(this.props.post, update);
    },
    is_redacted: function() {
      var post, ref1, ref2, ref3, user;
      post = this.props.post;
      user = this.props.post.user;
      if (post.deleted || ((ref1 = post.user) != null ? ref1.deleted : void 0)) {
        return true;
      } else if (((ref2 = post.user) != null ? ref2.suspended : void 0) || post.blocked) {
        return !((ref3 = this.state) != null ? ref3.show_blocked : void 0);
      } else {
        return false;
      }
    },
    render: function() {
      var post, ref1;
      post = this.props.post;
      return fragment({}, this.render_current_post(), ((ref1 = post.replies) != null ? ref1.length : void 0) ? this.render_children() : post.view_replies_url ? div({
        className: "view_more_replies"
      }, a({
        href: post.view_replies_url,
        className: "button outline forward_link"
      }, this.tt("community.post_list.view_more_in_thread"))) : void 0);
    },
    render_children: function() {
      var post;
      post = this.props.post;
      return div({
        className: classNames("community_post_replies", {
          top_level_replies: post.depth === 1
        })
      }, post.replies.map((function(_this) {
        return function(post, idx) {
          return P.Post({
            key: post.id,
            readonly: _this.props.readonly,
            idx: idx,
            post: post,
            current_user: _this.props.current_user,
            edit_post: _this.edit_child_post || (_this.edit_child_post = function(post, update) {
              var _post;
              return _this.edit_post({
                replies: (function() {
                  var i, len, ref1, results;
                  ref1 = this.props.post.replies;
                  results = [];
                  for (i = 0, len = ref1.length; i < len; i++) {
                    _post = ref1[i];
                    if (_post === post) {
                      if (update === "remove") {
                        continue;
                      }
                      results.push($.extend({}, post, update));
                    } else {
                      results.push(_post);
                    }
                  }
                  return results;
                }).call(_this)
              });
            }),
            urls: _this.props.urls,
            reply_form_params: _this.props.reply_form_params
          });
        };
      })(this)));
    },
    update_vote: function(vote) {
      var down_adjust, score_adjustment, up_adjust;
      score_adjustment = vote.score_adjustment || 0;
      up_adjust = Math.max(score_adjustment, 0);
      down_adjust = Math.min(score_adjustment, 0);
      return this.edit_post({
        up_votes: vote.up_score + up_adjust,
        down_votes: vote.down_score - down_adjust,
        vote: vote.score_adjustment ? {
          positive: vote.score_adjustment > 0
        } : null
      });
    },
    delete_post: function(type) {
      var delete_url, msg, params, post, ref1;
      if (type == null) {
        type = null;
      }
      post = this.props.post;
      msg = type === "hard" ? "Purging post will delete it permanently, along with any replies. Continue?" : "Are you sure you want to delete this post?";
      if (!confirm(msg)) {
        return;
      }
      if ((ref1 = this.state) != null ? ref1.deleting : void 0) {
        return;
      }
      this.setState({
        deleting: true
      });
      delete_url = this.props.urls.delete_url({
        id: post.id
      });
      params = {};
      if (type === "hard") {
        params.hard = "1";
      }
      return $.ajax({
        type: "POST",
        url: delete_url,
        data: I.with_csrf(params),
        dataType: "json",
        xhrFields: {
          withCredentials: true
        }
      }).done((function(_this) {
        return function(res) {
          return _this.edit_post({
            deleted: true,
            hard_deleted: res.type === "hard"
          });
        };
      })(this)).always((function(_this) {
        return function() {
          return _this.setState({
            deleting: false
          });
        };
      })(this));
    },
    render_current_post_moderation_event: function() {
      var moderation_event, post, user;
      post = this.props.post;
      user = this.props.post.user;
      moderation_event = post.moderation_event;
      if (post.deleted) {
        return div({
          className: "post_content"
        }, div({
          className: "post_body"
        }, em({
          className: "deleted_message"
        }, this.tt("community.post_list.deleted_post"))));
      }
      return fragment({}, span({
        className: "post_author"
      }, user.url && user.name ? a({
        href: user.url
      }, user.name) : span({
        className: "name_placeholder"
      }, "Unknown account")), span({
        className: "moderation_action"
      }, strong({}, moderation_event.action), moderation_event.target_name ? fragment({}, " ", a({
        href: moderation_event.target_url
      }, moderation_event.target_name)) : void 0, " ", span({
        className: "post_date",
        title: post.created_at + " UTC"
      }, a({
        href: post.url
      }, I.format_timestamp(post.created_at))), post.can_delete && !post.deleted && !this.props.readonly ? button({
        className: "textlike delete_post_btn post_action",
        type: "button",
        onClick: (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.delete_post();
          };
        })(this)
      }, this.tt("community.post_list.delete")) : void 0));
    },
    render_current_post_contents: function() {
      var avatar, base, base1, base2, post, ref1, ref2, ref3, ref4, ref5, ref6, ref7, user;
      post = this.props.post;
      user = this.props.post.user;
      avatar = R.Index.LazyImage({
        className: "post_avatar",
        width: 25,
        height: 25,
        src: user.avatar_url,
        src_set: user.avatar_url2x ? user.avatar_url + " 1x, " + user.avatar_url2x + " 2x" : void 0
      });
      return (post.just_added ? R.SlideDown : div)({
        className: "post_grid"
      }, post.vote_types === "ud" ? P.PostVoter({
        post_id: post.id,
        vote: post.vote,
        disabled: this.is_redacted(),
        urls: this.props.urls,
        on_vote: this.update_vote,
        current_user: this.props.current_user,
        login_url: typeof (base = this.props.urls).login_url === "function" ? base.login_url() : void 0
      }) : void 0, user.url ? a({
        href: user.url,
        className: "avatar_container"
      }, avatar) : div({
        className: "avatar_container"
      }, avatar), div({
        className: "post_header"
      }, span({
        className: "post_author"
      }, post.deleted ? span({
        className: "name_placeholder"
      }, "Deleted post") : user.deleted ? span({
        className: "name_placeholder"
      }, this.tt("community.post_list.deleted_account")) : post.blocked && !((ref1 = this.state) != null ? ref1.show_blocked : void 0) ? span({
        className: "name_placeholder"
      }, "Blocked account") : user.suspended ? span({
        className: "name_placeholder"
      }, this.tt("community.post_list.suspended_account")) : user.url && user.name ? a({
        href: user.url
      }, user.name) : void 0), span({
        className: "post_date",
        title: post.created_at + " UTC"
      }, a({
        href: post.url
      }, I.format_timestamp(post.created_at))), !this.is_redacted() && (post.edits_count || 0) > 0 ? fragment({}, " ", span({
        className: "edit_message",
        title: post.edited_at + " (" + post.edits_count + ")"
      }, this.tt("community.post_list.edited"))) : void 0, !this.is_redacted() && post.vote_types && (post.up_votes || post.down_votes) ? span({
        className: "vote_counts"
      }, post.up_votes ? span({
        className: "upvotes"
      }, "(+" + post.up_votes + ")") : void 0, post.down_votes ? span({
        className: "downvotes"
      }, "(-" + post.down_votes + ")") : void 0) : void 0), div({
        className: "post_content"
      }, post.deleted || ((ref2 = post.user) != null ? ref2.deleted : void 0) ? div({
        className: "post_body"
      }, em({
        className: "deleted_message"
      }, this.tt("community.post_list.deleted_post")), (post.can_moderate || post.admin_url) && !post.hard_deleted ? fragment({}, " (", button({
        className: "textlike",
        onClick: this.purge_post || (this.purge_post = (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.delete_post("hard").done(function() {
              return _this.edit_post("remove");
            });
          };
        })(this))
      }, "Purge"), ")") : void 0) : ((ref3 = post.user) != null ? ref3.suspended : void 0) && !((ref4 = this.state) != null ? ref4.show_blocked : void 0) ? div({
        className: "post_body"
      }, em({}, this.tt("community.post_list.post_from_suspended_account")), " (", button({
        className: "textlike",
        onClick: this.show_blocked_post || (this.show_blocked_post = (function(_this) {
          return function() {
            return _this.setState({
              show_blocked: true
            });
          };
        })(this))
      }, "Show post"), ")") : post.blocked && !((ref5 = this.state) != null ? ref5.show_blocked : void 0) ? div({
        className: "post_body"
      }, em({}, this.tt("community.post_list.post_from_blocked_account")), " (", button({
        className: "textlike",
        onClick: this.show_blocked_post || (this.show_blocked_post = (function(_this) {
          return function() {
            return _this.setState({
              show_blocked: true
            });
          };
        })(this))
      }, "Show post"), ", ", a({
        href: this.props.urls.blocks_url(),
        target: "_blank"
      }, this.tt("community.post_list.edit_blocks")), ")") : ((ref6 = this.state) != null ? ref6.editing : void 0) ? this.render_edit_form() : P.PostBody({
        key: post.body_html,
        body_html: post.body_html
      }), div({
        className: "post_footer"
      }, !this.is_redacted() ? post.vote_types === "u" ? P.PostLiker({
        post_id: post.id,
        vote: post.vote,
        urls: this.props.urls,
        on_vote: this.update_vote,
        current_user: this.props.current_user,
        login_url: typeof (base1 = this.props.urls).login_url === "function" ? base1.login_url() : void 0
      }) : void 0 : void 0, !this.is_redacted() && !this.props.readonly ? post.can_reply ? a({
        href: this.props.urls.reply_url({
          id: post.id
        }),
        className: "post_action reply_btn",
        onClick: this.props.reply_form_params ? this.on_click_reply || (this.on_click_reply = (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.setState(function(s) {
              if (s == null) {
                s = {};
              }
              return {
                replying_to: !s.replying_to
              };
            });
          };
        })(this)) : void 0
      }, this.tt("community.post_list.reply")) : !this.props.current_user && this.props.urls.login_url ? a({
        href: typeof (base2 = this.props.urls).login_url === "function" ? base2.login_url() : void 0,
        className: "post_action reply_btn",
        rel: "nofollow",
        target: "_blank"
      }, this.tt("community.post_list.reply")) : void 0 : void 0, post.can_edit && !this.props.readonly ? a({
        href: this.props.urls.edit_url({
          id: post.id
        }),
        className: "post_action",
        onClick: this.props.reply_form_params ? this.on_click_edit || (this.on_click_edit = (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.setState(function(s) {
              if (s == null) {
                s = {};
              }
              return {
                editing: !s.editing,
                replying_to: false
              };
            });
          };
        })(this)) : void 0
      }, this.tt("community.post_list.edit")) : void 0, post.can_delete && !post.deleted && !this.props.readonly ? a({
        href: "#",
        className: "post_action delete_post_btn",
        onClick: (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.delete_post();
          };
        })(this)
      }, post.is_topic ? this.tt("community.post_list.delete_topic") : this.tt("community.post_list.delete")) : void 0, !this.is_redacted() && post.can_report ? a({
        href: "#",
        className: "post_action render_post_btn",
        onClick: (function(_this) {
          return function(e) {
            var report_url;
            e.preventDefault();
            report_url = _this.props.urls.report_url({
              id: post.id
            });
            return I.Lightbox.open_remote(report_url, I.CommunityReportPostLightbox);
          };
        })(this)
      }, this.tt("community.post_list.report")) : void 0, user.id && post.ban_target && !this.props.readonly ? a({
        href: "#",
        className: "post_action ban_user_btn",
        onClick: (function(_this) {
          return function(e) {
            var ban_url;
            e.preventDefault();
            ban_url = _this.props.urls.ban_url(post.ban_target);
            ban_url += "?banned_user_id=" + user.id;
            return I.Lightbox.open_remote(ban_url, I.CommunityBanLightbox);
          };
        })(this)
      }, strong({}, this.tt("community.post_list.ban"))) : void 0, post.admin_url ? a({
        href: post.admin_url
      }, "Admin") : void 0), ((ref7 = this.state) != null ? ref7.replying_to : void 0) ? this.render_reply_form() : void 0));
    },
    render_edit_form: function() {
      var post;
      post = this.props.post;
      this.edit_form_cancel || (this.edit_form_cancel = fragment({}, " ", button({
        type: "button",
        className: "textlike",
        onClick: (function(_this) {
          return function() {
            return _this.setState({
              editing: false
            });
          };
        })(this)
      }, "Cancel")));
      return P.PostEditForm({
        edit_url: this.props.urls.edit_url({
          id: post.id
        }),
        more_buttons: this.edit_form_cancel,
        reply_form_params: this.props.reply_form_params,
        on_create_post: (function(_this) {
          return function(post) {
            _this.edit_post(post);
            return _this.setState({
              editing: false
            });
          };
        })(this)
      });
    },
    render_reply_form: function() {
      var ref1;
      return R.SlideDown({}, P.PostForm($.extend({
        submit_url: this.props.urls.reply_url({
          id: this.props.post.id
        }),
        autofocus: true,
        open: true,
        className: "inline_reply",
        key: "post-" + (((ref1 = this.state) != null ? ref1.post_counter : void 0) || 0),
        post_label: this.tt("community.post_form.post_reply"),
        remember_key: "reply:" + this.props.post.id,
        on_create_post: this.on_add_reply || (this.on_add_reply = (function(_this) {
          return function(post) {
            post.just_added = true;
            _this.setState(function(s) {
              return {
                replying_to: false,
                post_counter: (s.post_counter || 0) + 1
              };
            });
            return _this.edit_post({
              replies: [post].concat(_this.props.post.replies || [])
            });
          };
        })(this))
      }, this.props.reply_form_params)));
    },
    render_current_post: function() {
      var post, ref1, ref2, ref3;
      post = this.props.post;
      return this.enclose({
        className: classNames("community_post", {
          disabled: post.deleted || ((ref1 = post.user) != null ? ref1.suspended : void 0) || ((ref2 = post.user) != null ? ref2.deleted : void 0) || post.blocked,
          is_deleted: post.deleted,
          is_reply: post.depth > 1,
          is_blocked: post.blocked,
          is_suspended: (ref3 = post.user) != null ? ref3.suspended : void 0,
          has_replies: post.replies && post.replies.length,
          has_vote_column: post.vote_types === "ud",
          moderation_event: post.moderation_event
        }),
        id: "post-" + post.id
      }, this.props.len_posts && this.props.idx === 0 ? div({
        className: "post_anchor",
        id: "first-post"
      }) : void 0, this.props.len_posts && this.props.idx === this.props.len_posts - 1 ? div({
        className: "post_anchor",
        id: "last-post"
      }) : void 0, post.moderation_event ? this.render_current_post_moderation_event() : this.render_current_post_contents());
    }
  });

  P("PostList", {
    pure: true,
    propTypes: {
      children: types.array,
      urls: types.object
    },
    componentDidCatch: function(error, info) {
      I.event("error", "react", "Community.PostList");
      return this.setState({
        critical_error: true
      });
    },
    render: function() {
      var ref1;
      if ((ref1 = this.state) != null ? ref1.critical_error : void 0) {
        return h3({}, "There was an error rendering the comments, please ", a({
          href: "https://itch.io/support"
        }, "contact support"), " with a link to this page.");
      }
      if (!this.props.posts) {
        return null;
      }
      this.url_templates || (this.url_templates = (function(_this) {
        return function() {
          var k, out, ref2, v;
          out = {};
          ref2 = _this.props.urls;
          for (k in ref2) {
            if (!hasProp.call(ref2, k)) continue;
            v = ref2[k];
            out[k] = _.template(v);
          }
          return out;
        };
      })(this)());
      return this.enclose({}, this.props.posts.map((function(_this) {
        return function(post, idx) {
          var ref;
          ref = idx === 0 ? _this.first_post_ref || (_this.first_post_ref = React.createRef()) : void 0;
          return P.Post({
            ref: ref,
            key: post.id,
            readonly: _this.props.readonly,
            idx: idx,
            edit_post: _this.props.edit_post,
            len_posts: _this.props.posts.length,
            post: post,
            current_user: _this.props.current_user,
            urls: _this.url_templates,
            reply_form_params: _this.props.reply_form_params
          });
        };
      })(this)));
    }
  });

  P("LoadOnScroll", {
    componentWillUnmount: function() {
      return typeof this.unbind_visibility === "function" ? this.unbind_visibility() : void 0;
    },
    componentDidMount: function() {
      var el;
      el = ReactDOM.findDOMNode(this);
      return this.unbind_visibility = $(el).lazy_images({
        elements: [el],
        show_images: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this.props) != null ? ref1.on_seen() : void 0;
          };
        })(this)
      });
    },
    render: function() {
      return this.props.children;
    }
  });

  P("PostEditForm", {
    propTypes: {
      edit_url: types.string.isRequired
    },
    componentDidCatch: function(error, info) {
      I.event("error", "react", "Community.PostEditForm");
      return this.setState({
        critical_error: true
      });
    },
    getInitialState: function() {
      return {
        loading: true
      };
    },
    componentDidMount: function() {
      return $.ajax({
        type: "GET",
        dataType: "json",
        url: this.props.edit_url,
        xhrFields: {
          withCredentials: true
        }
      }).done((function(_this) {
        return function(res) {
          return _this.setState({
            loading: false,
            errors: res.errors,
            body_format: res.body_format,
            body: res.body
          });
        };
      })(this));
    },
    render: function() {
      var ref1;
      if ((ref1 = this.state) != null ? ref1.critical_error : void 0) {
        return h3({}, "There was an error editing this post, please ", a({
          href: "https://itch.io/support"
        }, "contact support"), " with a link to this page.");
      }
      if (this.state.body) {
        return P.PostForm($.extend({}, this.props.reply_form_params, {
          submit_url: this.props.edit_url,
          autofocus: true,
          open: true,
          className: "inline_edit",
          defaultValue: this.state.body,
          body_format: this.state.body_format,
          post_label: this.tt("misc.forms.save"),
          more_buttons: this.props.more_buttons,
          on_create_post: this.props.on_create_post
        }));
      } else {
        return div({}, "");
      }
    }
  });

  P("PostForm", {
    getInitialState: function() {
      return {
        open: this.props.open || false
      };
    },
    componentDidCatch: function(error, info) {
      return I.event("error", "react", "Community.PostForm");
    },
    render: function() {
      return this.enclose({}, this.state.open ? this.render_form() : this.render_pre_form());
    },
    render_pre_form: function() {
      return form({
        className: classNames("form post_form", this.props.className)
      }, input({
        className: "click_input",
        type: "text",
        placeholder: this.t("game.comments.write_your_comment"),
        onFocus: (function(_this) {
          return function() {
            return _this.setState({
              open: true,
              focus: true
            });
          };
        })(this)
      }));
    },
    render_form: function() {
      var ref1, ref2, ref3;
      return form({
        action: this.props.submit_url,
        ref: this.form_ref || (this.form_ref = React.createRef()),
        className: classNames("form post_form", this.props.className),
        onSubmit: (function(_this) {
          return function(e) {
            var ref1;
            if ((ref1 = _this.state) != null ? ref1.loading : void 0) {
              return;
            }
            e.preventDefault();
            _this.setState({
              loading: true
            });
            return I.remote_submit($(e.target), [
              {
                name: "format",
                value: "props"
              }
            ]).done(function(res) {
              var base, ref2;
              if (res.errors) {
                _this.setState({
                  needs_recaptcha: indexOf.call(res.errors, "recaptcha") >= 0,
                  errors: res.errors,
                  loading: false
                });
                return;
              }
              if (res.flash) {
                I.flash(res.flash);
              }
              if ((ref2 = _this.body_input_ref.current) != null) {
                ref2.clear_memory();
              }
              _this.setState({
                loading: false,
                needs_recaptcha: false,
                errors: null
              });
              if (res.post) {
                return typeof (base = _this.props).on_create_post === "function" ? base.on_create_post(res.post) : void 0;
              }
            });
          };
        })(this)
      }, ((ref1 = this.state) != null ? ref1.errors : void 0) ? R.Forms.FormErrors({
        errors: this.state.errors,
        animated: true,
        scroll_into_view: true
      }) : void 0, R.CSRF({}), this.props.body_format ? input({
        type: "hidden",
        name: "post[body_format]",
        value: this.props.body_format
      }) : void 0, (function() {
        switch (this.props.body_format || "html") {
          case "html":
            return R.Redactor({
              placeholder: "Required",
              ref: this.body_input_ref || (this.body_input_ref = React.createRef()),
              remember_key: this.props.remember_key,
              name: "post[body]",
              required: true,
              defaultValue: this.props.defaultValue,
              redactor_opts: $.extend({
                minHeight: 50,
                focus: this.props.autofocus || this.state.focus
              }, this.props.redactor_opts)
            });
          case "markdown":
            return R.Forms.MarkdownInput({
              ref: this.body_input_ref || (this.body_input_ref = React.createRef()),
              remember_key: this.props.remember_key,
              placeholder: "Required",
              defaultValue: this.props.defaultValue,
              name: "post[body]",
              autofocus: this.props.autofocus || this.state.focus,
              required: true,
              on_submit_hotkey: this.on_submit_hotkey_callback || (this.on_submit_hotkey_callback = (function(_this) {
                return function() {
                  var ref2, ref3;
                  return (ref2 = _this.submit_button_ref) != null ? (ref3 = ref2.current) != null ? ref3.click() : void 0 : void 0;
                };
              })(this))
            });
          default:
            return R.Forms.FormErrors({
              animated: true,
              scroll_into_view: true,
              errors: ["Don't know how to edit post with format " + this.state.body_format]
            });
        }
      }).call(this), ((ref2 = this.state) != null ? ref2.needs_recaptcha : void 0) ? R.Forms.RecaptchaInput({
        sitekey: this.props.recaptcha_sitekey
      }) : void 0, div({
        className: "buttons"
      }, button({
        className: "button",
        disabled: (ref3 = this.state) != null ? ref3.loading : void 0,
        ref: this.submit_button_ref || (this.submit_button_ref = React.createRef())
      }, this.props.post_label || this.tt("community.post_form.post")), this.props.more_buttons));
    }
  });

  R["package"]("Game")("Comments", {
    pure: true,
    getDefaultProps: function() {
      return {
        autoload_count: 1
      };
    },
    getInitialState: function() {
      return {
        posts: this.props.posts,
        pagination: this.props.pagination,
        autoload_count: this.props.autoload_count
      };
    },
    create_scroll_restore: function(el) {
      var from_top, offset_parent, scroll_top;
      el = $(el).find(".post_grid");
      if (!el.length) {
        return function() {};
      }
      offset_parent = el.offsetParent();
      scroll_top = window.document.documentElement.scrollTop;
      from_top = el.position().top - scroll_top;
      return function() {
        return window.document.documentElement.scrollTop = el.position().top - from_top;
      };
    },
    load_page: function(page) {
      var ref1;
      if (page == null) {
        page = "next_page";
      }
      if (!((ref1 = this.state.pagination) != null ? ref1[page] : void 0)) {
        return;
      }
      this.setState({
        loading: true
      });
      return $.getJSON(this.props.topic.url, this.state.pagination[page]).done((function(_this) {
        return function(res) {
          var el, first_post, pagination, post_list, posts, ref2, ref3, ref4, restore_position;
          if (res.posts) {
            pagination = Object.assign({}, _this.props.pagination);
            pagination[page] = (ref2 = res.pagination) != null ? ref2[page] : void 0;
            posts = (function() {
              switch (page) {
                case "prev_page":
                  return res.posts.concat(this.state.posts);
                case "next_page":
                  return this.state.posts.concat(res.posts);
              }
            }).call(_this);
            restore_position = page === "prev_page" ? (post_list = (ref3 = _this.post_list_ref) != null ? ref3.current : void 0, (first_post = post_list != null ? (ref4 = post_list.first_post_ref) != null ? ref4.current : void 0 : void 0) ? (el = ReactDOM.findDOMNode(first_post), _this.create_scroll_restore(el)) : void 0) : void 0;
            return _this.setState({
              loading: false,
              posts: posts,
              pagination: pagination
            }, restore_position);
          } else {
            return _this.setState({
              loading: false,
              pagination: null
            });
          }
        };
      })(this));
    },
    render: function() {
      var load_more_button, ref1, ref2, ref3, ref4;
      return this.enclose({}, h2({}, this.tt("game.comments.comments_header")), P.PostForm({
        key: "post-" + (((ref1 = this.state) != null ? ref1.post_counter : void 0) || 0),
        submit_url: this.props.post_form.submit_url,
        post_label: this.tt("game.comments.post_comment"),
        recaptcha_sitekey: this.props.recaptcha_sitekey,
        remember_key: this.props.remember_key || ("topic:" + this.props.topic.id),
        redactor_opts: this.props.post_form.redactor_opts,
        body_format: this.props.body_format,
        on_create_post: this.on_create_post || (this.on_create_post = (function(_this) {
          return function(post) {
            return _this.setState(function(s) {
              post.just_added = true;
              return {
                post_counter: (s.post_counter || 0) + 1,
                posts: [post].concat(s.posts || [])
              };
            });
          };
        })(this))
      }), this.state.pagination && this.state.pagination.prev_page ? p({
        className: "pagination_buttons"
      }, a({
        href: this.props.topic.url + "?" + ($.param(this.state.pagination.prev_page)),
        className: "load_posts_before",
        disabled: (ref2 = this.state) != null ? ref2.loading : void 0,
        onClick: this.load_prev_page || (this.load_prev_page = (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.load_page("prev_page");
          };
        })(this))
      }, "Show previous posts ↑")) : void 0, P.PostList({
        ref: this.post_list_ref || (this.post_list_ref = React.createRef()),
        posts: this.state.posts,
        urls: this.props.urls,
        current_user: this.props.current_user || I.current_user,
        reply_form_params: this.reply_form_params || (this.reply_form_params = {
          recaptcha_sitekey: this.props.recaptcha_sitekey,
          redactor_opts: this.props.post_form.redactor_opts,
          body_format: this.props.body_format
        }),
        edit_post: this.edit_post || (this.edit_post = (function(_this) {
          return function(post, update) {
            return _this.setState(function(s) {
              var _post;
              return {
                posts: (function() {
                  var i, len, ref3, results;
                  ref3 = s.posts;
                  results = [];
                  for (i = 0, len = ref3.length; i < len; i++) {
                    _post = ref3[i];
                    if (_post === post) {
                      if (update === "remove") {
                        continue;
                      }
                      results.push($.extend({}, post, update));
                    } else {
                      results.push(_post);
                    }
                  }
                  return results;
                })()
              };
            });
          };
        })(this))
      }), this.state.pagination && this.state.pagination.next_page ? (load_more_button = div({
        className: "pagination_buttons"
      }, a({
        href: this.props.topic.url + "?" + ($.param(this.state.pagination.next_page)),
        className: classNames("load_posts_after", {
          loading: (ref3 = this.state) != null ? ref3.loading : void 0
        }),
        onClick: this.load_next_page || (this.load_next_page = (function(_this) {
          return function(e) {
            var ref4;
            e.preventDefault();
            if ((ref4 = _this.state) != null ? ref4.loading : void 0) {
              return;
            }
            return _this.load_page("next_page");
          };
        })(this))
      }, ((ref4 = this.state) != null ? ref4.loading : void 0) ? "Loading..." : "Load more")), this.state.autoload_count > 0 ? P.LoadOnScroll({
        key: JSON.stringify(this.state.pagination),
        on_seen: (function(_this) {
          return function() {
            _this.setState(function(state) {
              return {
                autoload_count: state.autoload_count - 1
              };
            });
            return _this.load_page("next_page");
          };
        })(this)
      }, load_more_button) : load_more_button) : void 0);
    }
  });

  });

}).call(this);
(function() {
  I.libs.react.done(function() {;
  var P, _rdf, a, br, button, code, div, em, fieldset, form, fragment, h1, h2, h3, h4, h5, h6, iframe, img, input, label, legend, li, ol, optgroup, option, p, pre, section, select, span, strong, textarea, types, ul;

  _rdf = ReactDOMFactories;

  div = _rdf.div, span = _rdf.span, a = _rdf.a, br = _rdf.br, p = _rdf.p, ol = _rdf.ol, ul = _rdf.ul, li = _rdf.li, strong = _rdf.strong, em = _rdf.em, img = _rdf.img, form = _rdf.form, label = _rdf.label, input = _rdf.input, textarea = _rdf.textarea, button = _rdf.button, iframe = _rdf.iframe, h1 = _rdf.h1, h2 = _rdf.h2, h3 = _rdf.h3, h4 = _rdf.h4, h5 = _rdf.h5, h6 = _rdf.h6, pre = _rdf.pre, code = _rdf.code, select = _rdf.select, option = _rdf.option, section = _rdf.section, optgroup = _rdf.optgroup, fieldset = _rdf.fieldset, legend = _rdf.legend;

  fragment = React.createElement.bind(null, React.Fragment);

  fragment.type = React.fragment;

  P = R["package"]("Community");

  types = PropTypes;

  P("TopicVoter", {
    propTypes: {
      post_id: types.number.isRequired,
      vote: types.string,
      vote_url: types.string.isRequired,
      score: types.number.isRequired,
      adjustment: types.number,
      dir: types.string
    },
    getInitialState: function() {
      return {
        vote: this.props.vote
      };
    },
    vote: function(direction) {
      var opts, removing, url;
      if (!I.current_user) {
        window.location = this.login_url();
        return;
      }
      this.setState({
        loading: true
      });
      url = _.template(this.props.vote_url)({
        post_id: this.props.post_id
      });
      removing = false;
      opts = direction === this.state.vote ? (removing = true, {
        action: "remove"
      }) : {
        direction: direction
      };
      return $.ajax({
        url: url,
        type: "POST",
        dataType: "json",
        data: I.with_csrf(opts),
        xhrFields: {
          withCredentials: true
        }
      }).done((function(_this) {
        return function(res) {
          _this.setState({
            loading: false
          });
          if (res.success) {
            _this.setState({
              vote: !removing && direction,
              adjustment: res.score_adjustment
            });
            return $(ReactDOM.findDOMNode(_this)).find("button").trigger("i:refresh_tooltip");
          }
        };
      })(this)).fail((function(_this) {
        return function(xhr) {
          return _this.setState({
            loading: false,
            has_error: true
          });
        };
      })(this));
    },
    login_url: function() {
      return "/login?" + ($.param({
        return_to: window.location.toString(),
        intent: "community"
      }));
    },
    render: function() {
      var ref, score, vote_classes;
      score = this.props.score;
      if (this.state.vote) {
        score += (ref = this.state.adjustment) != null ? ref : this.props.adjustment;
      }
      vote_classes = "vote_btn button small";
      return div({}, button({
        type: "button",
        "aria-label": this.state.vote === "up" ? "Remove up vote" : "Vote up",
        className: classNames(vote_classes, "vote_up_btn icon-caret-up", {
          outline: this.state.vote !== "up",
          disabled: this.state.loading
        }),
        disabled: this.state.loading,
        onClick: (function(_this) {
          return function() {
            return _this.vote("up");
          };
        })(this)
      }), div({
        className: "vote_score"
      }, score), this.props.dir !== "up" ? button({
        type: "button",
        "aria-label": this.state.vote === "down" ? "Remove down vote" : "Vote down",
        className: classNames(vote_classes, "vote_down_btn icon-caret-down", {
          outline: this.state.vote !== "down",
          disabled: this.state.loading
        }),
        disabled: this.state.loading,
        onClick: (function(_this) {
          return function() {
            return _this.vote("down");
          };
        })(this)
      }) : void 0);
    }
  });

  });

}).call(this);
